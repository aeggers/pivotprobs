---
title: "Distributions on the unit simplex"
author: "Andy Eggers"
date: "26 August 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(patchwork)
devtools::load_all(".")
```

## Dirichlet 

For the Dirichlet I use the `gtools` functions, but this is written in a pretty poor way -- I wonder if I can speed things up by vectorizing that function.

To illustrate this, first let's take a bunch of draws from a Dirichlet density: 

```{r dir_draws}
n <- 500
alpha <- c(10, 8, 5)
dir_draws <- gtools::rdirichlet(n, alpha)
```

And plot them on the ternary: 

```{r dir_plot}
colnames(dir_draws) <- c("a", "b", "c")
as_tibble(dir_draws) %>% 
  mutate(x = a + .5*b,
         y = sqrt(3/4)*b) %>% 
  ggplot(aes(x = x, y = y)) + 
  geom_point(alpha = .5, size = 1, col = "blue") + 
  coord_fixed() + 
  theme_void() + 
  expand_limits(x = c(-.1, 1.1), y = sqrt(3/4)*c(-.1, 1.1)) + 
  annotate(geom = "text", x = c(1,.5,0), y = c(0,sqrt(3/4),0) + .05*c(-1,1,-1), label = c("a", "b", "c")) + 
  votevizr::geom_ternary_boundary()
```


We can also plot the density as a heatmap kind of thing. Annoyingly there are some blank spots between tiles, but there it is:

```{r grid_with_dir_density}
incr <- .005
the_seq_a <- seq(0, 1, by = incr)
the_seq <- apply(cbind(the_seq_a[1:(length(the_seq_a) - 1)], the_seq_a[2:length(the_seq_a)]), 1, mean)
gr <- expand_grid(a = the_seq, b = the_seq) %>% 
  filter(a + b < 1) %>% 
  mutate(c = 1 - a - b)
#          dens = gtools::ddirichlet(as.matrix(.), alpha = alpha))
gr$dens <- gtools::ddirichlet(as.matrix(gr), alpha = alpha)

gr 

gr %>%
  mutate(x = a + .5*b,
          y = sqrt(3/4)*b)  %>% 
  ggplot(aes(x = round(x, 12), y = round(y, 12))) +
  geom_tile(aes(fill = dens), width = incr) + 
  coord_fixed() +
  theme_void() +
  expand_limits(x = c(-.1, 1.1), y = sqrt(3/4)*c(-.1, 1.1)) +
  annotate(geom = "text", x = c(1,.5,0), y = c(0,sqrt(3/4),0) + .05*c(-1,1,-1), label = c("a", "b", "c")) +
   votevizr::geom_ternary_boundary()

#   scale_color_brewer()


```



## Logistic normal  

The Dirichlet makes some pretty extreme independence assumptions. One more general approach is the logistic normal distribution. The basic approach is to start with $k-1$ multivariate normally distributed variables with paramters $\mu$ and $\Sigma$, tack on a $k$th variable that is fixed at 0, and apply the "softmax" transformation (taking `exp()` of each one and then expressing as shares). This allows for dependence encoded in the $\Sigma$ matrix of the multivariate normal. Happily, the pdf of this distribution can be expressed in terms of $\mu$ and $\Sigma$.  It is used by Blei and Rafferty in place of Dirichlet in their correlated topic model. 

Let's illustrate this with a few examples.

First we'll make a function that will show the density of the multivariate normal and the density of the logistic normal side-by-side for one set of parameter values. 


```{r ln_plot_fn}
ln_plot_fn <- function(mu, sigma, title = "", mvn_incr = .05, ln_incr = .01){

  # create and populate mv normal density grid 
  the_seq_a <- seq(-2, 2, by = mvn_incr)
  the_seq <- apply(cbind(the_seq_a[1:(length(the_seq_a) - 1)],
                         the_seq_a[2:length(the_seq_a)]), 1, mean)
  mvn_gr <- expand_grid(a = the_seq, b = the_seq)
  
  mvn_gr$dens <- mvtnorm::dmvnorm(as.matrix(mvn_gr), mean = mu, sigma = sigma)

  # create and populate logistic normal density grid 
  the_seq_a <- seq(0, 1, by = ln_incr)
  the_seq <- apply(cbind(the_seq_a[1:(length(the_seq_a) - 1)],
                         the_seq_a[2:length(the_seq_a)]), 1, mean)
  ln_gr <- expand_grid(a = the_seq, b = the_seq) %>% 
    filter(a + b < 1) %>% 
    mutate(c = 1 - a - b)
  
  ln_gr$dens <- dlogisticnormal(as.matrix(ln_gr), mu = mu, sigma = sigma)
  
  # logistic normal plot on R2 
  mvn_gr %>%
    ggplot(aes(x = a, y = b)) +
    geom_tile(aes(fill = dplyr::ntile(dens, 7))) + 
    coord_fixed() +
    theme_bw() +
    scale_fill_gradientn(colors = RColorBrewer::brewer.pal(7, "Oranges")) + 
    labs(fill = "Density category") -> mvn_plot

  # logistic normal plot on the ternary 
  ln_gr %>%
    mutate(x = a + .5*b,
           y = sqrt(3/4)*b)  %>% 
    ggplot(aes(x = round(x, 12), y = round(y, 12))) +
    geom_tile(aes(fill = dplyr::ntile(dens, 7)), width = ln_incr) + 
    coord_fixed() +
    theme_void() +
    scale_fill_gradientn(colors = RColorBrewer::brewer.pal(7, "Oranges")) + 
    expand_limits(x = c(-.1, 1.1), y = sqrt(3/4)*c(-.1, 1.1)) +
    annotate(geom = "text", x = c(1,.5,0), y = c(0,sqrt(3/4),0) + .05*c(-1,1,-1), label = c("a", "b", "c")) +
    votevizr::geom_ternary_boundary() + 
    labs(fill = "Density category") -> ln_plot

  mvn_plot + ln_plot + plot_annotation(title = title)
}
```

And here is a little function to make a bivariate $\Sigma$ matrix from arguments: 

```{r sigma_func}
sigma_fn <- function(sigx, sigy, rho){
  matrix(
  c(sigx^2, rho*sigx*sigy,
    rho*sigx*sigy, sigy^2),
  ncol = 2, nrow = 2, byrow = T)
}
```

Now we apply these functions to some cases to get a feel for how this distribution works. 

```{r ln_neutral, cache = T, echo = F}
mu <- c(0, 0)
sigma <- sigma_fn(1,1,0)

ln_plot_fn(mu, sigma, title = "Neutral")
```

```{r ln_positive_correlation, cache = T, echo = F}
mu <- c(0, 0)
sigma <- sigma_fn(1,1,.25)

ln_plot_fn(mu, sigma, title = "Positive correlation")
```

```{r ln_negative_correlation, cache = T}
mu <- c(0, 0)
sigma <- sigma_fn(1,1,-.25)

ln_plot_fn(mu, sigma, title = "Negative correlation")
```

```{r ln_a_leading, cache = T, echo = F}
mu <- c(.5, 0)
sigma <- sigma_fn(1,1,0)

ln_plot_fn(mu, sigma, title = "a leading")
```

```{r ln_b_leading, cache = T, echo = F}
mu <- c(0, .5)
sigma <- sigma_fn(1,1,0)

ln_plot_fn(mu, sigma, title = "b leading")
```

```{r ln_c_leading, cache = T, echo = F}
mu <- c(-.5, -.5)
sigma <- sigma_fn(1,1,0)

ln_plot_fn(mu, sigma, title = "c leading")
```

```{r ln_a_noisy, cache = T, echo = F}
mu <- c(0, 0)
sigma <- sigma_fn(2,1,0)

ln_plot_fn(mu, sigma, title = "a noisier")
```

```{r ln_b_noisy, cache = T, echo = F}
mu <- c(0, 0)
sigma <- sigma_fn(1,2,0)

ln_plot_fn(mu, sigma, title = "b noisier")
```

```{r ln_a_and_b_noisier, cache = T, echo = F}
mu <- c(0, 0)
sigma <- sigma_fn(2,2,0)

ln_plot_fn(mu, sigma, title = "a and b noisier")
```


```{r ln_a_and_b_less_noisy, cache = T, echo = F}
mu <- c(0, 0)
sigma <- sigma_fn(.5,.5,0)

ln_plot_fn(mu, sigma, title = "a and b less noisy")
```
```{r ln_a_and_b_less_noisy_and_pos_correlated, cache = T, echo = F}
mu <- c(0, 0)
sigma <- sigma_fn(.5,.5,.5)

ln_plot_fn(mu, sigma, title = "a and b less noisy, positively correlated")
```
```{r ln_a_and_b_less_noisy_and_neg_correlated, cache = T, echo = F}
mu <- c(0, 0)
sigma <- sigma_fn(.5,.5,-.25)

ln_plot_fn(mu, sigma, title = "a and b less noisy, negatively correlated")
```





## Normalization

In `SimplicialCubature` I include a normalizing constant so that the density integrates to 1 over the unit simplex. Confirming: 

```{r normalizing_ln, cache = T}
out_3 <- SimplicialCubature::adaptIntegrateSimplex(logisticnormal_for_integration, S = diag(3), mu = mu, sigma = sigma)
out_3$integral 

out_4 <- SimplicialCubature::adaptIntegrateSimplex(logisticnormal_for_integration, S = diag(4), mu = rep(1, 3), sigma = diag(3)*.1)
out_4$integral 

out_5 <- SimplicialCubature::adaptIntegrateSimplex(logisticnormal_for_integration, S = diag(5), mu = rep(1, 4), sigma = diag(4)*.1, maxEvals = 100000, tol = .1)
out_5$message
out_5$integral 

```

